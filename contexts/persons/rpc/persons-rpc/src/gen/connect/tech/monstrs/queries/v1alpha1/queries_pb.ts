// @generated by protoc-gen-es v1.8.0 with parameter "target=ts"
// @generated from file tech/monstrs/queries/v1alpha1/queries.proto (package tech.monstrs.queries.v1alpha1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions } from '@bufbuild/protobuf'
import type { FieldList }         from '@bufbuild/protobuf'
import type { JsonReadOptions }   from '@bufbuild/protobuf'
import type { JsonValue }         from '@bufbuild/protobuf'
import type { PartialMessage }    from '@bufbuild/protobuf'
import type { PlainMessage }      from '@bufbuild/protobuf'

import { Message }                from '@bufbuild/protobuf'
import { Timestamp }              from '@bufbuild/protobuf'
import { proto3 }                 from '@bufbuild/protobuf'
import { protoInt64 }             from '@bufbuild/protobuf'

/**
 * @generated from message tech.monstrs.queries.v1alpha1.Query
 */
export class Query extends Message<Query> {
  constructor(data?: PartialMessage<Query>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.queries.v1alpha1.Query'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Query {
    return new Query().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Query {
    return new Query().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Query {
    return new Query().fromJsonString(jsonString, options)
  }

  static equals(
    a: Query | PlainMessage<Query> | undefined,
    b: Query | PlainMessage<Query> | undefined
  ): boolean {
    return proto3.util.equals(Query, a, b)
  }
}

/**
 * @generated from enum tech.monstrs.queries.v1alpha1.Query.OrderDirection
 */
export enum Query_OrderDirection {
  /**
   * @generated from enum value: ORDER_DIRECTION_ASC = 0;
   */
  ASC = 0,

  /**
   * @generated from enum value: ORDER_DIRECTION_DESC = 1;
   */
  DESC = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(Query_OrderDirection)
proto3.util.setEnumType(
  Query_OrderDirection,
  'tech.monstrs.queries.v1alpha1.Query.OrderDirection',
  [
    { no: 0, name: 'ORDER_DIRECTION_ASC' },
    { no: 1, name: 'ORDER_DIRECTION_DESC' },
  ]
)

/**
 * @generated from enum tech.monstrs.queries.v1alpha1.Query.Operator
 */
export enum Query_Operator {
  /**
   * @generated from enum value: OPERATOR_AND = 0;
   */
  AND = 0,

  /**
   * @generated from enum value: OPERATOR_OR = 1;
   */
  OR = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(Query_Operator)
proto3.util.setEnumType(Query_Operator, 'tech.monstrs.queries.v1alpha1.Query.Operator', [
  { no: 0, name: 'OPERATOR_AND' },
  { no: 1, name: 'OPERATOR_OR' },
])

/**
 * @generated from message tech.monstrs.queries.v1alpha1.Query.Pager
 */
export class Query_Pager extends Message<Query_Pager> {
  /**
   * @generated from field: int32 offset = 1;
   */
  offset = 0

  /**
   * @generated from field: int32 take = 2;
   */
  take = 0

  constructor(data?: PartialMessage<Query_Pager>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.queries.v1alpha1.Query.Pager'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'offset', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: 'take', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Query_Pager {
    return new Query_Pager().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Query_Pager {
    return new Query_Pager().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Query_Pager {
    return new Query_Pager().fromJsonString(jsonString, options)
  }

  static equals(
    a: Query_Pager | PlainMessage<Query_Pager> | undefined,
    b: Query_Pager | PlainMessage<Query_Pager> | undefined
  ): boolean {
    return proto3.util.equals(Query_Pager, a, b)
  }
}

/**
 * @generated from message tech.monstrs.queries.v1alpha1.Query.Order
 */
export class Query_Order extends Message<Query_Order> {
  /**
   * @generated from field: string field = 1;
   */
  field = ''

  /**
   * @generated from field: tech.monstrs.queries.v1alpha1.Query.OrderDirection direction = 2;
   */
  direction = Query_OrderDirection.ASC

  constructor(data?: PartialMessage<Query_Order>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.queries.v1alpha1.Query.Order'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'field', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'direction', kind: 'enum', T: proto3.getEnumType(Query_OrderDirection) },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Query_Order {
    return new Query_Order().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Query_Order {
    return new Query_Order().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Query_Order {
    return new Query_Order().fromJsonString(jsonString, options)
  }

  static equals(
    a: Query_Order | PlainMessage<Query_Order> | undefined,
    b: Query_Order | PlainMessage<Query_Order> | undefined
  ): boolean {
    return proto3.util.equals(Query_Order, a, b)
  }
}

/**
 * @generated from message tech.monstrs.queries.v1alpha1.Query.Search
 */
export class Query_Search extends Message<Query_Search> {
  /**
   * @generated from field: repeated tech.monstrs.queries.v1alpha1.Query.Search.Field fields = 1;
   */
  fields: Query_Search_Field[] = []

  /**
   * @generated from field: string value = 2;
   */
  value = ''

  constructor(data?: PartialMessage<Query_Search>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.queries.v1alpha1.Query.Search'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'fields', kind: 'message', T: Query_Search_Field, repeated: true },
    { no: 2, name: 'value', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Query_Search {
    return new Query_Search().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Query_Search {
    return new Query_Search().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Query_Search {
    return new Query_Search().fromJsonString(jsonString, options)
  }

  static equals(
    a: Query_Search | PlainMessage<Query_Search> | undefined,
    b: Query_Search | PlainMessage<Query_Search> | undefined
  ): boolean {
    return proto3.util.equals(Query_Search, a, b)
  }
}

/**
 * @generated from message tech.monstrs.queries.v1alpha1.Query.Search.Field
 */
export class Query_Search_Field extends Message<Query_Search_Field> {
  /**
   * @generated from field: repeated string path = 1;
   */
  path: string[] = []

  constructor(data?: PartialMessage<Query_Search_Field>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.queries.v1alpha1.Query.Search.Field'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'path', kind: 'scalar', T: 9 /* ScalarType.STRING */, repeated: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Query_Search_Field {
    return new Query_Search_Field().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Query_Search_Field {
    return new Query_Search_Field().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): Query_Search_Field {
    return new Query_Search_Field().fromJsonString(jsonString, options)
  }

  static equals(
    a: Query_Search_Field | PlainMessage<Query_Search_Field> | undefined,
    b: Query_Search_Field | PlainMessage<Query_Search_Field> | undefined
  ): boolean {
    return proto3.util.equals(Query_Search_Field, a, b)
  }
}

/**
 * @generated from message tech.monstrs.queries.v1alpha1.Query.StringValue
 */
export class Query_StringValue extends Message<Query_StringValue> {
  /**
   * @generated from field: string value = 1;
   */
  value = ''

  constructor(data?: PartialMessage<Query_StringValue>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.queries.v1alpha1.Query.StringValue'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'value', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Query_StringValue {
    return new Query_StringValue().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Query_StringValue {
    return new Query_StringValue().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Query_StringValue {
    return new Query_StringValue().fromJsonString(jsonString, options)
  }

  static equals(
    a: Query_StringValue | PlainMessage<Query_StringValue> | undefined,
    b: Query_StringValue | PlainMessage<Query_StringValue> | undefined
  ): boolean {
    return proto3.util.equals(Query_StringValue, a, b)
  }
}

/**
 * @generated from message tech.monstrs.queries.v1alpha1.Query.StringValues
 */
export class Query_StringValues extends Message<Query_StringValues> {
  /**
   * @generated from field: repeated string values = 1;
   */
  values: string[] = []

  constructor(data?: PartialMessage<Query_StringValues>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.queries.v1alpha1.Query.StringValues'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'values', kind: 'scalar', T: 9 /* ScalarType.STRING */, repeated: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Query_StringValues {
    return new Query_StringValues().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Query_StringValues {
    return new Query_StringValues().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): Query_StringValues {
    return new Query_StringValues().fromJsonString(jsonString, options)
  }

  static equals(
    a: Query_StringValues | PlainMessage<Query_StringValues> | undefined,
    b: Query_StringValues | PlainMessage<Query_StringValues> | undefined
  ): boolean {
    return proto3.util.equals(Query_StringValues, a, b)
  }
}

/**
 * @generated from message tech.monstrs.queries.v1alpha1.Query.IntValue
 */
export class Query_IntValue extends Message<Query_IntValue> {
  /**
   * @generated from field: int32 value = 1;
   */
  value = 0

  constructor(data?: PartialMessage<Query_IntValue>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.queries.v1alpha1.Query.IntValue'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'value', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Query_IntValue {
    return new Query_IntValue().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Query_IntValue {
    return new Query_IntValue().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Query_IntValue {
    return new Query_IntValue().fromJsonString(jsonString, options)
  }

  static equals(
    a: Query_IntValue | PlainMessage<Query_IntValue> | undefined,
    b: Query_IntValue | PlainMessage<Query_IntValue> | undefined
  ): boolean {
    return proto3.util.equals(Query_IntValue, a, b)
  }
}

/**
 * @generated from message tech.monstrs.queries.v1alpha1.Query.IntValues
 */
export class Query_IntValues extends Message<Query_IntValues> {
  /**
   * @generated from field: repeated int32 values = 1;
   */
  values: number[] = []

  constructor(data?: PartialMessage<Query_IntValues>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.queries.v1alpha1.Query.IntValues'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'values', kind: 'scalar', T: 5 /* ScalarType.INT32 */, repeated: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Query_IntValues {
    return new Query_IntValues().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Query_IntValues {
    return new Query_IntValues().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Query_IntValues {
    return new Query_IntValues().fromJsonString(jsonString, options)
  }

  static equals(
    a: Query_IntValues | PlainMessage<Query_IntValues> | undefined,
    b: Query_IntValues | PlainMessage<Query_IntValues> | undefined
  ): boolean {
    return proto3.util.equals(Query_IntValues, a, b)
  }
}

/**
 * @generated from message tech.monstrs.queries.v1alpha1.Query.Int64Value
 */
export class Query_Int64Value extends Message<Query_Int64Value> {
  /**
   * @generated from field: int64 value = 1;
   */
  value = protoInt64.zero

  constructor(data?: PartialMessage<Query_Int64Value>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.queries.v1alpha1.Query.Int64Value'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'value', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Query_Int64Value {
    return new Query_Int64Value().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Query_Int64Value {
    return new Query_Int64Value().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Query_Int64Value {
    return new Query_Int64Value().fromJsonString(jsonString, options)
  }

  static equals(
    a: Query_Int64Value | PlainMessage<Query_Int64Value> | undefined,
    b: Query_Int64Value | PlainMessage<Query_Int64Value> | undefined
  ): boolean {
    return proto3.util.equals(Query_Int64Value, a, b)
  }
}

/**
 * @generated from message tech.monstrs.queries.v1alpha1.Query.Int64Values
 */
export class Query_Int64Values extends Message<Query_Int64Values> {
  /**
   * @generated from field: repeated int64 values = 1;
   */
  values: bigint[] = []

  constructor(data?: PartialMessage<Query_Int64Values>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.queries.v1alpha1.Query.Int64Values'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'values', kind: 'scalar', T: 3 /* ScalarType.INT64 */, repeated: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Query_Int64Values {
    return new Query_Int64Values().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Query_Int64Values {
    return new Query_Int64Values().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Query_Int64Values {
    return new Query_Int64Values().fromJsonString(jsonString, options)
  }

  static equals(
    a: Query_Int64Values | PlainMessage<Query_Int64Values> | undefined,
    b: Query_Int64Values | PlainMessage<Query_Int64Values> | undefined
  ): boolean {
    return proto3.util.equals(Query_Int64Values, a, b)
  }
}

/**
 * @generated from message tech.monstrs.queries.v1alpha1.Query.BooleanValue
 */
export class Query_BooleanValue extends Message<Query_BooleanValue> {
  /**
   * @generated from field: bool value = 1;
   */
  value = false

  constructor(data?: PartialMessage<Query_BooleanValue>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.queries.v1alpha1.Query.BooleanValue'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'value', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Query_BooleanValue {
    return new Query_BooleanValue().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Query_BooleanValue {
    return new Query_BooleanValue().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): Query_BooleanValue {
    return new Query_BooleanValue().fromJsonString(jsonString, options)
  }

  static equals(
    a: Query_BooleanValue | PlainMessage<Query_BooleanValue> | undefined,
    b: Query_BooleanValue | PlainMessage<Query_BooleanValue> | undefined
  ): boolean {
    return proto3.util.equals(Query_BooleanValue, a, b)
  }
}

/**
 * @generated from message tech.monstrs.queries.v1alpha1.Query.DateValue
 */
export class Query_DateValue extends Message<Query_DateValue> {
  /**
   * @generated from field: google.protobuf.Timestamp value = 1;
   */
  value?: Timestamp

  constructor(data?: PartialMessage<Query_DateValue>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.queries.v1alpha1.Query.DateValue'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'value', kind: 'message', T: Timestamp },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Query_DateValue {
    return new Query_DateValue().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Query_DateValue {
    return new Query_DateValue().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Query_DateValue {
    return new Query_DateValue().fromJsonString(jsonString, options)
  }

  static equals(
    a: Query_DateValue | PlainMessage<Query_DateValue> | undefined,
    b: Query_DateValue | PlainMessage<Query_DateValue> | undefined
  ): boolean {
    return proto3.util.equals(Query_DateValue, a, b)
  }
}

/**
 * @generated from message tech.monstrs.queries.v1alpha1.Query.IDConditions
 */
export class Query_IDConditions extends Message<Query_IDConditions> {
  /**
   * @generated from field: tech.monstrs.queries.v1alpha1.Query.StringValues in = 1;
   */
  in?: Query_StringValues

  /**
   * @generated from field: tech.monstrs.queries.v1alpha1.Query.StringValue eq = 2;
   */
  eq?: Query_StringValue

  /**
   * @generated from field: tech.monstrs.queries.v1alpha1.Query.BooleanValue exists = 3;
   */
  exists?: Query_BooleanValue

  constructor(data?: PartialMessage<Query_IDConditions>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.queries.v1alpha1.Query.IDConditions'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'in', kind: 'message', T: Query_StringValues },
    { no: 2, name: 'eq', kind: 'message', T: Query_StringValue },
    { no: 3, name: 'exists', kind: 'message', T: Query_BooleanValue },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Query_IDConditions {
    return new Query_IDConditions().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Query_IDConditions {
    return new Query_IDConditions().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): Query_IDConditions {
    return new Query_IDConditions().fromJsonString(jsonString, options)
  }

  static equals(
    a: Query_IDConditions | PlainMessage<Query_IDConditions> | undefined,
    b: Query_IDConditions | PlainMessage<Query_IDConditions> | undefined
  ): boolean {
    return proto3.util.equals(Query_IDConditions, a, b)
  }
}

/**
 * @generated from message tech.monstrs.queries.v1alpha1.Query.ID
 */
export class Query_ID extends Message<Query_ID> {
  /**
   * @generated from field: tech.monstrs.queries.v1alpha1.Query.Operator operator = 1;
   */
  operator = Query_Operator.AND

  /**
   * @generated from field: tech.monstrs.queries.v1alpha1.Query.IDConditions conditions = 2;
   */
  conditions?: Query_IDConditions

  constructor(data?: PartialMessage<Query_ID>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.queries.v1alpha1.Query.ID'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'operator', kind: 'enum', T: proto3.getEnumType(Query_Operator) },
    { no: 2, name: 'conditions', kind: 'message', T: Query_IDConditions },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Query_ID {
    return new Query_ID().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Query_ID {
    return new Query_ID().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Query_ID {
    return new Query_ID().fromJsonString(jsonString, options)
  }

  static equals(
    a: Query_ID | PlainMessage<Query_ID> | undefined,
    b: Query_ID | PlainMessage<Query_ID> | undefined
  ): boolean {
    return proto3.util.equals(Query_ID, a, b)
  }
}

/**
 * @generated from message tech.monstrs.queries.v1alpha1.Query.DateRangeConditions
 */
export class Query_DateRangeConditions extends Message<Query_DateRangeConditions> {
  /**
   * @generated from field: tech.monstrs.queries.v1alpha1.Query.DateValue from = 1;
   */
  from?: Query_DateValue

  /**
   * @generated from field: tech.monstrs.queries.v1alpha1.Query.DateValue to = 2;
   */
  to?: Query_DateValue

  constructor(data?: PartialMessage<Query_DateRangeConditions>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.queries.v1alpha1.Query.DateRangeConditions'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'from', kind: 'message', T: Query_DateValue },
    { no: 2, name: 'to', kind: 'message', T: Query_DateValue },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): Query_DateRangeConditions {
    return new Query_DateRangeConditions().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): Query_DateRangeConditions {
    return new Query_DateRangeConditions().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): Query_DateRangeConditions {
    return new Query_DateRangeConditions().fromJsonString(jsonString, options)
  }

  static equals(
    a: Query_DateRangeConditions | PlainMessage<Query_DateRangeConditions> | undefined,
    b: Query_DateRangeConditions | PlainMessage<Query_DateRangeConditions> | undefined
  ): boolean {
    return proto3.util.equals(Query_DateRangeConditions, a, b)
  }
}

/**
 * @generated from message tech.monstrs.queries.v1alpha1.Query.DateRange
 */
export class Query_DateRange extends Message<Query_DateRange> {
  /**
   * @generated from field: tech.monstrs.queries.v1alpha1.Query.Operator operator = 1;
   */
  operator = Query_Operator.AND

  /**
   * @generated from field: tech.monstrs.queries.v1alpha1.Query.DateRangeConditions conditions = 2;
   */
  conditions?: Query_DateRangeConditions

  constructor(data?: PartialMessage<Query_DateRange>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.queries.v1alpha1.Query.DateRange'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'operator', kind: 'enum', T: proto3.getEnumType(Query_Operator) },
    { no: 2, name: 'conditions', kind: 'message', T: Query_DateRangeConditions },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Query_DateRange {
    return new Query_DateRange().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Query_DateRange {
    return new Query_DateRange().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Query_DateRange {
    return new Query_DateRange().fromJsonString(jsonString, options)
  }

  static equals(
    a: Query_DateRange | PlainMessage<Query_DateRange> | undefined,
    b: Query_DateRange | PlainMessage<Query_DateRange> | undefined
  ): boolean {
    return proto3.util.equals(Query_DateRange, a, b)
  }
}

/**
 * @generated from message tech.monstrs.queries.v1alpha1.Query.DateConditions
 */
export class Query_DateConditions extends Message<Query_DateConditions> {
  /**
   * @generated from field: tech.monstrs.queries.v1alpha1.Query.DateValue eq = 1;
   */
  eq?: Query_DateValue

  /**
   * @generated from field: tech.monstrs.queries.v1alpha1.Query.BooleanValue exists = 2;
   */
  exists?: Query_BooleanValue

  constructor(data?: PartialMessage<Query_DateConditions>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.queries.v1alpha1.Query.DateConditions'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'eq', kind: 'message', T: Query_DateValue },
    { no: 2, name: 'exists', kind: 'message', T: Query_BooleanValue },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Query_DateConditions {
    return new Query_DateConditions().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Query_DateConditions {
    return new Query_DateConditions().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): Query_DateConditions {
    return new Query_DateConditions().fromJsonString(jsonString, options)
  }

  static equals(
    a: Query_DateConditions | PlainMessage<Query_DateConditions> | undefined,
    b: Query_DateConditions | PlainMessage<Query_DateConditions> | undefined
  ): boolean {
    return proto3.util.equals(Query_DateConditions, a, b)
  }
}

/**
 * @generated from message tech.monstrs.queries.v1alpha1.Query.Date
 */
export class Query_Date extends Message<Query_Date> {
  /**
   * @generated from field: tech.monstrs.queries.v1alpha1.Query.Operator operator = 1;
   */
  operator = Query_Operator.AND

  /**
   * @generated from field: tech.monstrs.queries.v1alpha1.Query.DateConditions conditions = 2;
   */
  conditions?: Query_DateConditions

  constructor(data?: PartialMessage<Query_Date>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.queries.v1alpha1.Query.Date'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'operator', kind: 'enum', T: proto3.getEnumType(Query_Operator) },
    { no: 2, name: 'conditions', kind: 'message', T: Query_DateConditions },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Query_Date {
    return new Query_Date().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Query_Date {
    return new Query_Date().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Query_Date {
    return new Query_Date().fromJsonString(jsonString, options)
  }

  static equals(
    a: Query_Date | PlainMessage<Query_Date> | undefined,
    b: Query_Date | PlainMessage<Query_Date> | undefined
  ): boolean {
    return proto3.util.equals(Query_Date, a, b)
  }
}

/**
 * @generated from message tech.monstrs.queries.v1alpha1.Query.StringConditions
 */
export class Query_StringConditions extends Message<Query_StringConditions> {
  /**
   * @generated from field: tech.monstrs.queries.v1alpha1.Query.StringValues in = 1;
   */
  in?: Query_StringValues

  /**
   * @generated from field: tech.monstrs.queries.v1alpha1.Query.StringValue eq = 2;
   */
  eq?: Query_StringValue

  /**
   * @generated from field: tech.monstrs.queries.v1alpha1.Query.StringValue contains = 3;
   */
  contains?: Query_StringValue

  constructor(data?: PartialMessage<Query_StringConditions>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.queries.v1alpha1.Query.StringConditions'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'in', kind: 'message', T: Query_StringValues },
    { no: 2, name: 'eq', kind: 'message', T: Query_StringValue },
    { no: 3, name: 'contains', kind: 'message', T: Query_StringValue },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): Query_StringConditions {
    return new Query_StringConditions().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): Query_StringConditions {
    return new Query_StringConditions().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): Query_StringConditions {
    return new Query_StringConditions().fromJsonString(jsonString, options)
  }

  static equals(
    a: Query_StringConditions | PlainMessage<Query_StringConditions> | undefined,
    b: Query_StringConditions | PlainMessage<Query_StringConditions> | undefined
  ): boolean {
    return proto3.util.equals(Query_StringConditions, a, b)
  }
}

/**
 * @generated from message tech.monstrs.queries.v1alpha1.Query.String
 */
export class Query_String extends Message<Query_String> {
  /**
   * @generated from field: tech.monstrs.queries.v1alpha1.Query.Operator operator = 1;
   */
  operator = Query_Operator.AND

  /**
   * @generated from field: tech.monstrs.queries.v1alpha1.Query.StringConditions conditions = 2;
   */
  conditions?: Query_StringConditions

  constructor(data?: PartialMessage<Query_String>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.queries.v1alpha1.Query.String'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'operator', kind: 'enum', T: proto3.getEnumType(Query_Operator) },
    { no: 2, name: 'conditions', kind: 'message', T: Query_StringConditions },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Query_String {
    return new Query_String().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Query_String {
    return new Query_String().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Query_String {
    return new Query_String().fromJsonString(jsonString, options)
  }

  static equals(
    a: Query_String | PlainMessage<Query_String> | undefined,
    b: Query_String | PlainMessage<Query_String> | undefined
  ): boolean {
    return proto3.util.equals(Query_String, a, b)
  }
}

/**
 * @generated from message tech.monstrs.queries.v1alpha1.Query.IntConditions
 */
export class Query_IntConditions extends Message<Query_IntConditions> {
  /**
   * @generated from field: tech.monstrs.queries.v1alpha1.Query.IntValues in = 1;
   */
  in?: Query_IntValues

  /**
   * @generated from field: tech.monstrs.queries.v1alpha1.Query.IntValue eq = 2;
   */
  eq?: Query_IntValue

  constructor(data?: PartialMessage<Query_IntConditions>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.queries.v1alpha1.Query.IntConditions'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'in', kind: 'message', T: Query_IntValues },
    { no: 2, name: 'eq', kind: 'message', T: Query_IntValue },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Query_IntConditions {
    return new Query_IntConditions().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Query_IntConditions {
    return new Query_IntConditions().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): Query_IntConditions {
    return new Query_IntConditions().fromJsonString(jsonString, options)
  }

  static equals(
    a: Query_IntConditions | PlainMessage<Query_IntConditions> | undefined,
    b: Query_IntConditions | PlainMessage<Query_IntConditions> | undefined
  ): boolean {
    return proto3.util.equals(Query_IntConditions, a, b)
  }
}

/**
 * @generated from message tech.monstrs.queries.v1alpha1.Query.Int
 */
export class Query_Int extends Message<Query_Int> {
  /**
   * @generated from field: tech.monstrs.queries.v1alpha1.Query.Operator operator = 1;
   */
  operator = Query_Operator.AND

  /**
   * @generated from field: tech.monstrs.queries.v1alpha1.Query.IntConditions conditions = 2;
   */
  conditions?: Query_IntConditions

  constructor(data?: PartialMessage<Query_Int>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.queries.v1alpha1.Query.Int'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'operator', kind: 'enum', T: proto3.getEnumType(Query_Operator) },
    { no: 2, name: 'conditions', kind: 'message', T: Query_IntConditions },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Query_Int {
    return new Query_Int().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Query_Int {
    return new Query_Int().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Query_Int {
    return new Query_Int().fromJsonString(jsonString, options)
  }

  static equals(
    a: Query_Int | PlainMessage<Query_Int> | undefined,
    b: Query_Int | PlainMessage<Query_Int> | undefined
  ): boolean {
    return proto3.util.equals(Query_Int, a, b)
  }
}

/**
 * @generated from message tech.monstrs.queries.v1alpha1.Query.Int64Conditions
 */
export class Query_Int64Conditions extends Message<Query_Int64Conditions> {
  /**
   * @generated from field: tech.monstrs.queries.v1alpha1.Query.Int64Values in = 1;
   */
  in?: Query_Int64Values

  /**
   * @generated from field: tech.monstrs.queries.v1alpha1.Query.Int64Value eq = 2;
   */
  eq?: Query_Int64Value

  constructor(data?: PartialMessage<Query_Int64Conditions>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.queries.v1alpha1.Query.Int64Conditions'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'in', kind: 'message', T: Query_Int64Values },
    { no: 2, name: 'eq', kind: 'message', T: Query_Int64Value },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): Query_Int64Conditions {
    return new Query_Int64Conditions().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Query_Int64Conditions {
    return new Query_Int64Conditions().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): Query_Int64Conditions {
    return new Query_Int64Conditions().fromJsonString(jsonString, options)
  }

  static equals(
    a: Query_Int64Conditions | PlainMessage<Query_Int64Conditions> | undefined,
    b: Query_Int64Conditions | PlainMessage<Query_Int64Conditions> | undefined
  ): boolean {
    return proto3.util.equals(Query_Int64Conditions, a, b)
  }
}

/**
 * @generated from message tech.monstrs.queries.v1alpha1.Query.Int64
 */
export class Query_Int64 extends Message<Query_Int64> {
  /**
   * @generated from field: tech.monstrs.queries.v1alpha1.Query.Operator operator = 1;
   */
  operator = Query_Operator.AND

  /**
   * @generated from field: tech.monstrs.queries.v1alpha1.Query.Int64Conditions conditions = 2;
   */
  conditions?: Query_Int64Conditions

  constructor(data?: PartialMessage<Query_Int64>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.queries.v1alpha1.Query.Int64'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'operator', kind: 'enum', T: proto3.getEnumType(Query_Operator) },
    { no: 2, name: 'conditions', kind: 'message', T: Query_Int64Conditions },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Query_Int64 {
    return new Query_Int64().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Query_Int64 {
    return new Query_Int64().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Query_Int64 {
    return new Query_Int64().fromJsonString(jsonString, options)
  }

  static equals(
    a: Query_Int64 | PlainMessage<Query_Int64> | undefined,
    b: Query_Int64 | PlainMessage<Query_Int64> | undefined
  ): boolean {
    return proto3.util.equals(Query_Int64, a, b)
  }
}
